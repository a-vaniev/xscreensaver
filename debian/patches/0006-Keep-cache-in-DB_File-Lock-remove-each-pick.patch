From 4d7c51bba18e0be56d60626fe7f7bb0a8f0dbb3a Mon Sep 17 00:00:00 2001
From: Marcin Owsiany <marcin@owsiany.pl>
Date: Wed, 28 Aug 2013 11:45:26 -0700
Subject: [PATCH 6/7] Keep cache in DB_File::Lock, remove each pick.

First, keep cache in a database rather than a plain text file. Second, whenever
a file is picked, remove the file from cache, so that every file is shown at
most once. Refresh the cache once it goes empty.
---
 driver/xscreensaver-getimage-file | 150 +++++++++++++++++++++++---------------
 1 file changed, 93 insertions(+), 57 deletions(-)

diff --git a/driver/xscreensaver-getimage-file b/driver/xscreensaver-getimage-file
index 7d946ec..d3090f3 100755
--- a/driver/xscreensaver-getimage-file
+++ b/driver/xscreensaver-getimage-file
@@ -52,6 +52,8 @@ use bytes;  # Larry can take Unicode and shove it up his ass sideways.
 use Digest::MD5 qw(md5_base64);
 use LWP::Simple qw($ua);
 
+use DB_File::Lock;  # For the cache file
+
 
 my $progname = $0; $progname =~ s@.*/@@g;
 my $version = q{ $Revision: 1.30 $ }; $version =~ s/^[^0-9]+([0-9.]+).*$/$1/;
@@ -235,57 +237,62 @@ sub spotlight_all_files($) {
 # running at once, one will wait for the other, instead of both of
 # them spanking the same file system at the same time.
 #
-my $cache_fd = undef;
-my $cache_file_name = undef;
-my $read_cache_p = 0;
-
-sub read_cache($) {
-  my ($dir) = @_;
-
-  return () unless ($cache_p);
 
+sub cache_file() {
   my $dd = "$ENV{HOME}/Library/Caches";    # MacOS location
+  my $f;
   if (-d $dd) {
-    $cache_file_name = "$dd/org.jwz.xscreensaver.getimage.cache";
+    $f = "$dd/org.jwz.xscreensaver.getimage.cache";
   } elsif (-d "$ENV{HOME}/tmp") {
-    $cache_file_name = "$ENV{HOME}/tmp/.xscreensaver-getimage.cache";
+    $f = "$ENV{HOME}/tmp/.xscreensaver-getimage.cache";
   } else {
-    $cache_file_name = "$ENV{HOME}/.xscreensaver-getimage.cache";
+    $f = "$ENV{HOME}/.xscreensaver-getimage.cache";
   }
+  return $f;
+}
+
+my %cache;
+my $cache_file_name = cache_file;
+my $read_cache_p = 0;
 
+sub read_cache($) {
+  my ($dir) = @_;
+
+  return () unless ($cache_p);
+ 
   print STDERR "$progname: awaiting lock: $cache_file_name\n"
     if ($verbose > 1);
 
   my $file = $cache_file_name;
-  open ($cache_fd, '+>>', $file) || error ("unable to write $file: $!");
-  flock ($cache_fd, LOCK_EX)     || error ("unable to lock $file: $!");
-  seek ($cache_fd, 0, 0)         || error ("unable to rewind $file: $!");
-
-  my $mtime = (stat($cache_fd))[9];
+  unless (tie %cache, "DB_File::Lock", $file, O_RDWR | O_CREAT, 0, $DB_HASH, 'write') {
+    if (-e $file) { # try to recover
+      unlink $file or error ("unable to delete cache file $file: $!");
+      tie %cache, "DB_File::Lock", $file, O_RDWR | O_CREAT, 0, $DB_HASH, 'write' or error ("unable to open cache $file: $!");
+    } else {
+      error ("unable to open cache $file: $!");
+    }
+  }
+ 
+  my $mtime = $cache{timestamp} || 0;
 
   if ($mtime + $cache_max_age < time) {
     print STDERR "$progname: cache is too old\n" if ($verbose);
     return ();
   }
 
-  my $odir = <$cache_fd>;
-  $odir =~ s/[\r\n]+$//s if defined ($odir);
+  my $odir = $cache{dir};
   if (!defined ($odir) || ($dir ne $odir)) {
     print STDERR "$progname: cache is for $odir, not $dir\n"
       if ($verbose && $odir);
     return ();
   }
 
-  my @files = ();
-  while (<$cache_fd>) { 
-    s/[\r\n]+$//s;
-    push @files, "$odir/$_";
-  }
-
+  my @files = map { $_ =~ s,^file:,,;"$odir/$_" } grep /^file:/, keys %cache;
+  
   print STDERR "$progname: " . ($#files+1) . " files in cache\n"
     if ($verbose);
 
-  $read_cache_p = 1;
+  $read_cache_p = 1 if @files;
   return @files;
 }
 
@@ -300,28 +307,21 @@ sub write_cache($) {
 
   if (! $read_cache_p) {
 
-    truncate ($cache_fd, 0) ||
-      error ("unable to truncate $cache_file_name: $!");
-    seek ($cache_fd, 0, 0) ||
-      error ("unable to rewind $cache_file_name: $!");
-
     if ($#all_files >= 0) {
-      print $cache_fd "$dir\n";
+      $cache{dir} = $dir;
       foreach (@all_files) {
         my $f = $_; # stupid Perl. do this to avoid modifying @all_files!
-        $f =~ s@^\Q$dir\L/@@so || die;  # remove $dir from front
-        print $cache_fd "$f\n";
+        $f =~ s@^\Q$dir\L/@file:@so || die;  # remove $dir from front, put file: there
+        $cache{$f} = 1;
       }
+      $cache{timestamp} = time;
     }
 
     print STDERR "$progname: cached " . ($#all_files+1) . " files\n"
       if ($verbose);
   }
 
-  flock ($cache_fd, LOCK_UN) ||
-    error ("unable to unlock $cache_file_name: $!");
-  close ($cache_fd);
-  $cache_fd = undef;
+  untie %cache;
 }
 
 
@@ -627,27 +627,24 @@ sub mirror_feed($) {
   return ($url, $dir);
 }
 
+sub wipe_cache($) {
+  my $dir = shift;
 
-sub find_random_file($) {
-  my ($dir) = @_;
-
-  if ($use_spotlight_p == -1) {
-    $use_spotlight_p = 0;
-    if (-x '/usr/bin/mdfind') {
-      $use_spotlight_p = 1;
-    }
-  }
+  return unless ($cache_p);
+  unlink $cache_file_name;
+}
 
-  my $url;
-  ($url, $dir) = mirror_feed ($dir);
+sub cache_forget($$) {
+  my $dir = shift;
+  my $file = shift;
 
-  if ($url) {
-    $use_spotlight_p = 0;
-    print STDERR "$progname: $dir is cache for $url\n" if ($verbose > 1);
-  }
+  return unless ($cache_p);
 
-  @all_files = read_cache ($dir);
+  delete $cache{'file:'.$file};
+}
 
+sub maybe_get_files($) {
+  my $dir = shift;
   if ($#all_files >= 0) {
     # got it from the cache...
 
@@ -671,15 +668,17 @@ sub find_random_file($) {
       if ($verbose);
   }
 
-  write_cache ($dir);
-
-#  @all_files = sort(@all_files);
+  @all_files = sort(@all_files);
 
   if ($#all_files < 0) {
     print STDERR "$progname: no files in $dir\n";
     exit 1;
   }
+}
 
+sub pick_file($$) {
+  my $dir = shift;
+  my $url = shift;
   my $max_tries = 50;
   for (my $i = 0; $i < $max_tries; $i++) {
 
@@ -687,7 +686,7 @@ sub find_random_file($) {
     my $file = $all_files[$n];
     if (large_enough_p ($file)) {
       if (! $url) {
-        $file =~ s@^\Q$dir\L/@@so || die;  # remove $dir from front
+        $file =~ s@^\Q$dir\L/@@so || die "unexpected file [$file]";  # remove $dir from front
       }
       return $file;
     }
@@ -695,6 +694,43 @@ sub find_random_file($) {
 
   print STDERR "$progname: no suitable images in $dir " .
                "(after $max_tries tries)\n";
+  return undef;
+}
+  
+sub find_random_file($) {
+  my ($dir) = @_;
+
+  if ($use_spotlight_p == -1) {
+    $use_spotlight_p = 0;
+    if (-x '/usr/bin/mdfind') {
+      $use_spotlight_p = 1;
+    }
+  }
+
+  my $url;
+  ($url, $dir) = mirror_feed ($dir);
+
+  if ($url) {
+    $use_spotlight_p = 0;
+    print STDERR "$progname: $dir is cache for $url\n" if ($verbose > 1);
+  }
+
+  @all_files = read_cache ($dir);
+  
+  maybe_get_files ($dir);
+  my $file = pick_file ($dir, $url);
+  if (not defined $file) {
+    wipe_cache ($dir);
+    @all_files = ();
+    maybe_get_files ($dir);
+    $file = pick_file ($dir, $url);
+  }
+  cache_forget ($dir, $file) if defined $file;
+
+  write_cache ($dir);
+
+  return $file if defined $file;
+
   exit 1;
 }
 
-- 
1.8.4

